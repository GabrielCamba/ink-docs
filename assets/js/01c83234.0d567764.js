"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[2722],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=c(a),h=r,m=p["".concat(s,".").concat(h)]||p[h]||u[h]||l;return a?n.createElement(m,o(o({ref:t},d),{},{components:a})):n.createElement(m,o({ref:t},d))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[p]="string"==typeof e?e:r,o[1]=i;for(var c=2;c<l;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},14835:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var n=a(87462),r=(a(67294),a(3905));const l={title:"Upgradeable Contracts",slug:"/basics/upgradeable-contracts",hide_title:!0},o=void 0,i={unversionedId:"basics/upgradeability",id:"version-5.x/basics/upgradeability",title:"Upgradeable Contracts",description:"Even though smart contracts are intended to be immutable by design,",source:"@site/versioned_docs/version-5.x/basics/upgradeability.md",sourceDirName:"basics",slug:"/basics/upgradeable-contracts",permalink:"/5.x/basics/upgradeable-contracts",draft:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/versioned_docs/version-5.x/basics/upgradeability.md",tags:[],version:"5.x",frontMatter:{title:"Upgradeable Contracts",slug:"/basics/upgradeable-contracts",hide_title:!0},sidebar:"reference",previous:{title:"Cross-Contract Calling",permalink:"/5.x/basics/cross-contract-calling"},next:{title:"Environment Functions",permalink:"/5.x/basics/environment-functions"}},s={},c=[{value:"Proxy Forwarding",id:"proxy-forwarding",level:2},{value:"Properties",id:"properties",level:3},{value:"Example",id:"example",level:3},{value:"Delegating execution to foreign Contract Code with <code>delegate_call</code>",id:"delegating-execution-to-foreign-contract-code-with-delegate_call",level:2},{value:"Properties",id:"properties-1",level:3},{value:"Example",id:"example-1",level:3},{value:"Note on the usage of wildcard selectors",id:"note-on-the-usage-of-wildcard-selectors",level:2},{value:"Note on <code>CallFlags</code>",id:"note-on-callflags",level:2},{value:"Replacing Contract Code with <code>set_code_hash()</code>",id:"replacing-contract-code-with-set_code_hash",level:2},{value:"Properties",id:"properties-2",level:3},{value:"Example",id:"example-2",level:3},{value:"Storage Compatibility",id:"storage-compatibility",level:3},{value:"A little note on the determinism of contract addresses",id:"a-little-note-on-the-determinism-of-contract-addresses",level:3},{value:"Examples",id:"examples",level:2}],d={toc:c},p="wrapper";function u(e){let{components:t,...a}=e;return(0,r.kt)(p,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("img",{src:"/img/title/upgradeable-contract.svg",className:"titlePic"}),(0,r.kt)("h1",{id:"upgradeable-contracts"},"Upgradeable Contracts"),(0,r.kt)("p",null,"Even though smart contracts are intended to be immutable by design,\nit is often necessary to perform an upgrade of a smart contract. "),(0,r.kt)("p",null,"The developer may need to fix a critical bug or introduce a new feature."),(0,r.kt)("p",null,"For this type of scenario, ink! has different upgrade strategies."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#upgradeable-contracts"},"Upgradeable Contracts"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#proxy-forwarding"},"Proxy Forwarding"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#properties"},"Properties")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#example"},"Example")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#delegating-execution-to-foreign-contract-code-with-delegate_call"},"Delegating execution to foreign Contract Code with ",(0,r.kt)("inlineCode",{parentName:"a"},"delegate_call")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#properties-1"},"Properties")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#example-1"},"Example")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#note-on-the-usage-of-wildcard-selectors"},"Note on the usage of wildcard selectors")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#note-on-callflags"},"Note on ",(0,r.kt)("inlineCode",{parentName:"a"},"CallFlags"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#replacing-contract-code-with-set_code_hash"},"Replacing Contract Code with ",(0,r.kt)("inlineCode",{parentName:"a"},"set_code_hash()")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#properties-2"},"Properties")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#example-2"},"Example")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#storage-compatibility"},"Storage Compatibility")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#a-little-note-on-the-determinism-of-contract-addresses"},"A little note on the determinism of contract addresses")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#examples"},"Examples"))))),(0,r.kt)("h2",{id:"proxy-forwarding"},"Proxy Forwarding"),(0,r.kt)("p",null,"This method relies on the ability of contracts to proxy calls to other contracts."),(0,r.kt)("h3",{id:"properties"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Forwards any call that does not match a selector of itself to another contract."),(0,r.kt)("li",{parentName:"ul"},"The other contract needs to be deployed on-chain."),(0,r.kt)("li",{parentName:"ul"},"State is stored in the storage of the contract to which calls are forwarded.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"User ---- tx ---\x3e Proxy ----------\x3e Implementation_v0\n                     |\n                      ------------\x3e Implementation_v1\n                     |\n                      ------------\x3e Implementation_v2\n")),(0,r.kt)("h3",{id:"example"},"Example"),(0,r.kt)("p",null,"Our proxy contract will have these 2 storage fields:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct Proxy {\n    /// The `AccountId` of a contract where any call that does not match a\n    /// selector of this contract is forwarded to.\n    forward_to: AccountId,\n    /// The `AccountId` of a privileged account that can update the\n    /// forwarding address. This address is set to the account that\n    /// instantiated this contract.\n    admin: AccountId,\n}\n")),(0,r.kt)("p",null,"We then need a way to change the address of a contract to which we forward calls to\nand the actual message selector to proxy the call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'impl Proxy {\n    /// Changes the `AccountId` of the contract where any call that does\n    /// not match a selector of this contract is forwarded to.\n    ///\n    /// # Note\n    /// Only one extra message with a well-known selector `@` is allowed.\n    #[ink(message, selector = @)]\n    pub fn change_forward_address(&mut self, new_address: AccountId) {\n        assert_eq!(\n            self.env().caller(),\n            self.admin,\n            "caller {:?} does not have sufficient permissions, only {:?} does",\n            self.env().caller(),\n            self.admin,\n        );\n        self.forward_to = new_address;\n    }\n\n    /// Fallback message for a contract call that doesn\'t match any\n    /// of the other message selectors.\n    ///\n    /// # Note:\n    ///\n    /// - We allow payable messages here and would forward any optionally supplied\n    ///   value as well.\n    /// - If the self receiver were `forward(&mut self)` here, this would not\n    ///   have any effect whatsoever on the contract we forward to.\n    #[ink(message, payable, selector = _)]\n    pub fn forward(&self) -> u32 {\n        ink::env::call::build_call::<ink::env::DefaultEnvironment>()\n            .call(self.forward_to)\n            .transferred_value(self.env().transferred_value())\n            .call_flags(\n                ink::env::CallFlags::default()\n                    .set_forward_input(true)\n                    .set_tail_call(true),\n            )\n            .invoke()\n            .unwrap_or_else(|err| {\n                panic!(\n                    "cross-contract call to {:?} failed due to {:?}",\n                    self.forward_to, err\n                )\n            });\n        unreachable!(\n            "the forwarded call will never return since `tail_call` was set"\n        );\n    }\n}\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Take a look at the selector pattern in the attribute macro: by declaring ",(0,r.kt)("inlineCode",{parentName:"p"},"selector = _"),"\nwe specify that all other messages should be handled by this message selector.")),(0,r.kt)("p",null,"Using this pattern, you can introduce other message to your proxy contract.\nAny messages that are not matched in the proxy contract\nwill be forwarded to the specified contract address."),(0,r.kt)("h2",{id:"delegating-execution-to-foreign-contract-code-with-delegate_call"},"Delegating execution to foreign Contract Code with ",(0,r.kt)("inlineCode",{parentName:"h2"},"delegate_call")),(0,r.kt)("p",null,"Similar to proxy-forwarding we can delegate execution to another code hash uploaded on-chain."),(0,r.kt)("h3",{id:"properties-1"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Delegates any call that does not match a selector of itself to another contract."),(0,r.kt)("li",{parentName:"ul"},"Code is required to be uploaded on-chain, but is not required to be instantiated."),(0,r.kt)("li",{parentName:"ul"},"State is stored in the storage of the original contract which submits the call."),(0,r.kt)("li",{parentName:"ul"},"Storage layout must be identical between both contract codes.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"                                (Storage of Contract A)\nUser ---- tx ---\x3e Contract A ----------\x3e Code_v0\n                     |                     ^\n                     |                     |\n                     \u230a_____________________\u230b\n                    Storage is delegated to\n")),(0,r.kt)("h3",{id:"example-1"},"Example"),(0,r.kt)("p",null,"Suppose we have defined of the caller contract as following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct Delegator {\n    addresses: Mapping<AccountId, i32, ManualKey<0x23>>,\n    counter: i32,\n}\n")),(0,r.kt)("p",null,"Then let's define two messages that separately calls to update ",(0,r.kt)("inlineCode",{parentName:"p"},"addresses")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"counter")," separately:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'/// Increment the current value using delegate call.\n#[ink(message)]\npub fn inc_delegate(&self, hash: Hash) {\n    let selector = ink::selector_bytes!("inc");\n    let _ = build_call::<DefaultEnvironment>()\n        .delegate(hash)\n        // if the receiver is set to `&mut self`,\n        // then any changes made in `inc_delegate()` before the delegate call\n        // will be persisted, and any changes made within delegate call will be discarded.\n\n        // Therefore, it is advised to use `&self` receiver with a mutating delegate call,\n        // or `.set_tail_call(true)` to flag that any changes made by delegate call should be flushed into storage. \n        // .call_flags(CallFlags::default().set_tail_call(true))\n        .exec_input(ExecutionInput::new(Selector::new(selector)))\n        .returns::<()>()\n        .try_invoke();\n}\n\n/// Adds entry to `addresses` using delegate call.\n/// Note that we don\'t need `set_tail_call(true)` flag\n/// because `Mapping` updates the storage instantly on-demand.\n#[ink(message)]\npub fn add_entry_delegate(&mut self, hash: Hash) {\n    let selector = ink::selector_bytes!("append_address_value");\n    let _ = build_call::<DefaultEnvironment>()\n        .delegate(hash)\n        .exec_input(ExecutionInput::new(Selector::new(selector)))\n        .returns::<()>()\n        .try_invoke();\n}\n')),(0,r.kt)("p",null,"ink! provides an intuitive call builder API for you to compose your call.\nAs you can see that ",(0,r.kt)("inlineCode",{parentName:"p"},"inc_delegate()")," can be built a call in slightly different manner than ",(0,r.kt)("inlineCode",{parentName:"p"},"add_entry_delegate()"),".\nThat's because if the delegated code modifies layout-full storage\n(i.e. it contains at least non-",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy"),", non-",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping")," field),\neither the receiver should be set to ",(0,r.kt)("inlineCode",{parentName:"p"},"&self")," or the ",(0,r.kt)("inlineCode",{parentName:"p"},".set_tail_call(true)")," flag of ",(0,r.kt)("inlineCode",{parentName:"p"},"CallFlags")," needs to be specified, and the storage layouts must match."),(0,r.kt)("p",null,"This is due to the way ink! execution call stack is operated. Non-",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy"),", non-",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping")," field are first loaded into the memory.\nIf ",(0,r.kt)("inlineCode",{parentName:"p"},"&mut self")," receiver is used, then when delegate call is completed, the original state before the call will be persisted and flushed into the storage.\nTherefore, ",(0,r.kt)("inlineCode",{parentName:"p"},".set_tail_call(true)")," needs to be set to indicate that, that delegate call's storage context is the final (i.e. _tail) one that needs to be flushed.\nThis also makes any code after the delegate call unreachable.\nWith ",(0,r.kt)("inlineCode",{parentName:"p"},"&self")," receiver, ",(0,r.kt)("inlineCode",{parentName:"p"},".set_tail_call(true)")," is not required since no storage flushing happens at the end of the original caller's function.\n(see ",(0,r.kt)("a",{parentName:"p",href:"https://substrate.stackexchange.com/a/3352/3098"},"Stack Exchange Answer")," for details on how changes are flushed into storage)."),(0,r.kt)("admonition",{title:"Key compatibility",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If the delegated code modifies ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping")," field, the keys must be identical and ",(0,r.kt)("inlineCode",{parentName:"p"},".set_tail_call(true)")," is optional\nregardless of the function receiver.\nThis is because ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping")," interact with the storage directly instead of loading and flushing storage states.")),(0,r.kt)("p",null,'Now let\'s look at the "delegatee" code:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[ink::contract]\npub mod delegatee {\n    use ink::storage::{\n        traits::ManualKey,\n        Mapping,\n    };\n    #[ink(storage)]\n    pub struct Delegatee {\n        // `ManualKey` must be the same as in the original contract.\n        addresses: Mapping<AccountId, i32, ManualKey<0x23>>,\n        counter: i32,\n        // Uncommenting below line will break storage compatibility.\n        // flag: bool,\n    }\n\n    impl Delegatee {\n        /// When using the delegate call. You only upload the code of the delegatee\n        /// contract. However, the code and storage do not get initialized.\n        ///\n        /// Because of this. The constructor actually never gets called.\n        #[allow(clippy::new_without_default)]\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            unreachable!(\n                "Constructors are not called when upgrading using `set_code_hash`."\n            )\n        }\n\n        /// Increments the current value.\n        #[ink(message)]\n        pub fn inc(&mut self) {\n            self.counter = self.counter.checked_add(2).unwrap();\n        }\n\n        /// Adds current value of counter to the `addresses`\n        #[ink(message)]\n        pub fn append_address_value(&mut self) {\n            let caller = self.env().caller();\n            self.addresses.insert(caller, &self.counter);\n        }\n    }\n}\n')),(0,r.kt)("p",null,"As you can see, delegatee's code looks like a normal ink! Smart Contract with some important features:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Storage layout is identical to the original contract's storage"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addresses")," mapping key is identical"),(0,r.kt)("li",{parentName:"ul"},"Constructor does not have any logic, as the code is never instantiated. (It can be, but plays no effect on the execution)")),(0,r.kt)("h2",{id:"note-on-the-usage-of-wildcard-selectors"},"Note on the usage of wildcard selectors"),(0,r.kt)("p",null,"When working with cross-contract calls, developers are required to be aware of the some important changes."),(0,r.kt)("p",null,"Since ink! 5 we have restricted the usage of the wildcard selector due to\n",(0,r.kt)("a",{parentName:"p",href:"https://blog.openzeppelin.com/security-review-ink-cargo-contract#custom-selectors-could-facilitate-proxy-selector-clashing-attacks"},"security reasons"),"."),(0,r.kt)("admonition",{title:"Beware",type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"Due to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/1676"},"IIP-2"),", ink! only allows\nto contain a single message with a well-known selector ",(0,r.kt)("inlineCode",{parentName:"p"},"@")," when the other message\nwith the wildcard selector ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," is defined.")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/tree/master/integration-tests/wildcard-selector"},"example"),"\nfor illustration on how it can be used in practice."),(0,r.kt)("h2",{id:"note-on-callflags"},"Note on ",(0,r.kt)("inlineCode",{parentName:"h2"},"CallFlags")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"CallFlags")," provide fine-grained control over the cross-contract execution."),(0,r.kt)("p",null,"Some useful properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Re-entry is disable by default. It can be enabled with ",(0,r.kt)("inlineCode",{parentName:"li"},".set_allow_reentry(true)")," flag."),(0,r.kt)("li",{parentName:"ul"},"The call execution context is returned to the caller by default. You can finish execution in the callee with ",(0,r.kt)("inlineCode",{parentName:"li"},".set_tail_call(true)")," flag."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},".set_clone_input(true)")," clones the input of the caller's messages. It can be used with when ",(0,r.kt)("inlineCode",{parentName:"li"},".set_tail_call(false)"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},".set_forward_input(true)")," consumes the input of the caller's message which can be used after.  It can be used with when ",(0,r.kt)("inlineCode",{parentName:"li"},".set_tail_call(true)"),". ")),(0,r.kt)("h2",{id:"replacing-contract-code-with-set_code_hash"},"Replacing Contract Code with ",(0,r.kt)("inlineCode",{parentName:"h2"},"set_code_hash()")),(0,r.kt)("p",null,"Following ",(0,r.kt)("a",{parentName:"p",href:"https://docs.substrate.io/maintain/runtime-upgrades/"},"Substrate's runtime upgradeability"),"\nphilosophy, ink! also supports an easy way to update your contract code via the special function\n",(0,r.kt)("a",{parentName:"p",href:"https://paritytech.github.io/ink/ink_env/fn.set_code_hash.html"},(0,r.kt)("inlineCode",{parentName:"a"},"set_code_hash()")),"."),(0,r.kt)("h3",{id:"properties-2"},"Properties"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Updates the contract code using ",(0,r.kt)("inlineCode",{parentName:"li"},"set_code_hash()"),".\nThis effectively replaces the code which is executed for the contract address."),(0,r.kt)("li",{parentName:"ul"},"The other contract needs to be deployed on-chain."),(0,r.kt)("li",{parentName:"ul"},"State is stored in the storage of the originally instantiated contract.")),(0,r.kt)("h3",{id:"example-2"},"Example"),(0,r.kt)("p",null,"Just add the following function to the contract you want to upgrade in the future."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'/// Modifies the code which is used to execute calls to this contract address (`AccountId`).\n///\n/// We use this to upgrade the contract logic. We don\'t do any authorization here, any caller\n/// can execute this method. In a production contract you would do some authorization here.\n#[ink(message)]\npub fn set_code(&mut self, code_hash: [u8; 32]) {\n    ink::env::set_code_hash(&code_hash).unwrap_or_else(|err| {\n        panic!(\n            "Failed to `set_code_hash` to {:?} due to {:?}",\n            code_hash, err\n        )\n    });\n    ink::env::debug_println!("Switched code hash to {:?}.", code_hash);\n}\n')),(0,r.kt)("h3",{id:"storage-compatibility"},"Storage Compatibility"),(0,r.kt)("p",null,"It is the developer's responsibility to ensure\nthat the new contract's storage is compatible with the storage of the contract that is replaced."),(0,r.kt)("admonition",{title:"Beware",type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"You should not change the order in which the contract state variables are declared, nor their type!"),(0,r.kt)("p",{parentName:"admonition"},"Violating the restriction will not prevent a successful compilation,\nbut will result in ",(0,r.kt)("strong",{parentName:"p"},"the mix-up of values")," or ",(0,r.kt)("strong",{parentName:"p"},"failure to read the storage correctly"),".\nThis can be a result of severe errors in the application utilizing the contract.")),(0,r.kt)("p",null,"If the storage of your contract looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct YourContract {\n    x: u32,\n    y: bool,\n}\n")),(0,r.kt)("p",null,"The procedures listed below will make it ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"invalid"))),(0,r.kt)("p",null,"Changing the order of variables:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct YourContract {\n    y: bool,\n    x: u32,\n}\n")),(0,r.kt)("p",null,"Removing an existing variable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct YourContract {\n    x: u32,\n}\n")),(0,r.kt)("p",null,"Changing the type of a variable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct YourContract {\n    x: u64,\n    y: bool,\n}\n")),(0,r.kt)("p",null,"Introducing a new variable before any of the existing ones:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct YourContract {\n    z: Vec<u32>,\n    x: u32,\n    y: bool,\n}\n")),(0,r.kt)("h3",{id:"a-little-note-on-the-determinism-of-contract-addresses"},"A little note on the determinism of contract addresses"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If your contract utilizes this approach, it no-longer holds a deterministic address assumption.\nYou can no longer assume that a contract address identifies a specific code hash.\nPlease refer to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/pull/10690#issuecomment-1025702389"},"the issue"),"\nfor more details.")),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("p",null,"Examples of upgradable contracts can be found in the\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink-examples/tree/main/upgradeable-contracts"},"ink! repository"),"."))}u.isMDXComponent=!0}}]);
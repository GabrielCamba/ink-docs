"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[3271],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,f=d["".concat(l,".").concat(m)]||d[m]||u[m]||o;return n?i.createElement(f,r(r({ref:t},p),{},{components:n})):i.createElement(f,r({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},84775:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=n(87462),a=(n(67294),n(3905));const o={title:"Events",slug:"/basics/events",hide_title:!0},r=void 0,s={unversionedId:"basics/events",id:"version-5.x/basics/events",title:"Events",description:"An ink! smart contract may define events that it can emit during contract execution.",source:"@site/versioned_docs/version-5.x/basics/events.md",sourceDirName:"basics",slug:"/basics/events",permalink:"/5.x/basics/events",draft:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/versioned_docs/version-5.x/basics/events.md",tags:[],version:"5.x",frontMatter:{title:"Events",slug:"/basics/events",hide_title:!0},sidebar:"reference",previous:{title:"Mutating Storage Values",permalink:"/5.x/basics/mutating-values"},next:{title:"Selectors",permalink:"/5.x/basics/selectors"}},l={},c=[{value:"Example",id:"example",level:2},{value:"Event Definition",id:"event-definition",level:2},{value:"Legacy syntax for inline Event definitions",id:"legacy-syntax-for-inline-event-definitions",level:3},{value:"Topics",id:"topics",level:3},{value:"Signature Topic",id:"signature-topic",level:4},{value:"Anonymous Events",id:"anonymous-events",level:4},{value:"Emitting Events in a Constructor",id:"emitting-events-in-a-constructor",level:2},{value:"Emitting Events from Messages",id:"emitting-events-from-messages",level:2},{value:"Cost of using Events",id:"cost-of-using-events",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...o}=e;return(0,a.kt)(d,(0,i.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("img",{src:"/img/title/balloons-1.svg",className:"titlePic"}),(0,a.kt)("h1",{id:"events"},"Events"),(0,a.kt)("p",null,"An ink! smart contract may define events that it can emit during contract execution.\nEmitting events can be used by third party tools to query information about a contract's\nexecution and state."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Contract execution via transaction",src:n(31658).Z,width:"1780",height:"1000"})),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("p",null,"The following example ink! contract shows how an event ",(0,a.kt)("inlineCode",{parentName:"p"},"Transferred")," is defined and\nemitted in the ",(0,a.kt)("inlineCode",{parentName:"p"},"#[ink(constructor)]"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink::contract]\nmod erc20 {\n    /// Defines an event that is emitted\n    /// every time value is transferred.\n    #[ink(event)]\n    pub struct Transferred {\n        from: Option<AccountId>,\n        to: Option<AccountId>,\n        value: Balance,\n    }\n\n    #[ink(storage)]\n    pub struct Erc20 {\n        total_supply: Balance,\n        // more fields ...\n    }\n\n    impl Erc20 {\n        #[ink(constructor)]\n        pub fn new(initial_supply: Balance) -> Self {\n            let caller = Self::env().caller();\n            Self::env().emit_event(Transferred {\n                from: None,\n                to: Some(caller),\n                value: initial_supply,\n            });\n            Self { total_supply: initial_supply }\n        }\n\n        #[ink(message)]\n        pub fn total_supply(&self) -> Balance {\n            self.total_supply\n        }\n    }\n}\n")),(0,a.kt)("p",null,"See our ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink-examples/blob/main/erc20/lib.rs"},(0,a.kt)("inlineCode",{parentName:"a"},"ERC20 example contract")),"\nfor an elaborate example which uses events."),(0,a.kt)("h2",{id:"event-definition"},"Event Definition"),(0,a.kt)("p",null,"Since ink! version 5.0, events can be defined independently of the contract which emits them.\nEvents can now be defined once and shared across multiple contracts. "),(0,a.kt)("p",null,"This is useful for events for contracts which conform to standards such as ERC-20:\ncontract indexers/explorers are now able to group all e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"Transferred")," events."),(0,a.kt)("p",null,"This is how an event definition looks:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use ink::primitives::AccountId;\n\n#[ink::event]\npub struct Transferred {\n    #[ink(topic)]\n    from: Option<AccountId>,\n    #[ink(topic)]\n    to: Option<AccountId>,\n    amount: u128,\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that generics are ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/issues/2044"},"not currently supported"),"\n, so the concrete types of ",(0,a.kt)("inlineCode",{parentName:"p"},"Environment"),"\nspecific types such as ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountId")," must match up with the types used in the contract.")),(0,a.kt)("p",null,"This definition can exist within a contract definition module (inline events), in a different\nmodule in the same crate or even in a different crate to be shared by multiple contracts."),(0,a.kt)("h3",{id:"legacy-syntax-for-inline-event-definitions"},"Legacy syntax for inline Event definitions"),(0,a.kt)("p",null,"Events defined within a ",(0,a.kt)("inlineCode",{parentName:"p"},"#[ink::contract]")," module can continue to use the original syntax for an\nevent definition, using the ",(0,a.kt)("inlineCode",{parentName:"p"},"#[ink(event)]")," attribute. Under the covers this is simply expanded\nto the new top level ",(0,a.kt)("inlineCode",{parentName:"p"},"#[ink::event]")," macro, so both events defined using the legacy style and\nusing the new ",(0,a.kt)("inlineCode",{parentName:"p"},"event")," attribute macro directly will behave exactly the same."),(0,a.kt)("h3",{id:"topics"},"Topics"),(0,a.kt)("p",null,"When an event is emitted, 0 or more topics can be associated with it. The event is then indexed\ntogether with other events with the same topic value."),(0,a.kt)("p",null,"An event's fields can be annotated with ",(0,a.kt)("inlineCode",{parentName:"p"},"#[ink(topic)]")," (see example), which will result in a\ntopic derived from the value of that field being emitted together with the event."),(0,a.kt)("p",null,"Topics are by default a 32 byte array (",(0,a.kt)("inlineCode",{parentName:"p"},"[u8; 32]"),"), although this is configurable on the\nPolkadot SDK runtime level. If the SCALE encoded bytes of a field value are <= 32, then the\nencoded bytes are used directly as the topic value. "),(0,a.kt)("p",null,"For example, in the common case of indexing a field of type ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountId"),", where the default\n",(0,a.kt)("inlineCode",{parentName:"p"},"AccountId")," type is 32 bytes in length, the topic value will be the encoded account id itself. This\nmakes it easy to filter for all events which have a topic of a specific ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountId"),"."),(0,a.kt)("p",null,"If however the size of the encoded bytes of the value of a field exceeds 32, then the encoded\nbytes will be hashed using the ",(0,a.kt)("inlineCode",{parentName:"p"},"Blake2x256")," hasher."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Topics are a native concept in the Polkadot SDK, and can be queried via ",(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/frame-system/latest/frame_system/pallet/storage_types/struct.EventTopics.html"},(0,a.kt)("inlineCode",{parentName:"a"},"EventTopics")))),(0,a.kt)("p",null,"How to choose which fields to make topics? A good rule of thumb is to ask yourself if somebody\nmight want to search for this topic. For this reason the ",(0,a.kt)("inlineCode",{parentName:"p"},"amount")," in the example ",(0,a.kt)("inlineCode",{parentName:"p"},"Transferred")," event\nabove was not made indexable \u2012 there will most probably be a lot of different events with differing\namounts each."),(0,a.kt)("h4",{id:"signature-topic"},"Signature Topic"),(0,a.kt)("p",null,"By default all events have a signature topic. This allows indexing of all events of the same\ntype, emitted by different contracts. The ",(0,a.kt)("inlineCode",{parentName:"p"},"#[ink::event]")," macro generates a signature topic at\ncompile time by hashing the name of the event concatenated with the ",(0,a.kt)("em",{parentName:"p"},"names of the types")," of the all\nthe field\nnames:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'blake2b("Event(field1_type,field2_type)")`\n')),(0,a.kt)("p",null,"So for our ",(0,a.kt)("inlineCode",{parentName:"p"},"Transferred")," example it will be: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'blake2b("Transferred(Option<AccountId>,Option<AccountId>,u128)")`\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Important caveat: because the ",(0,a.kt)("em",{parentName:"p"},"name")," of the field type is used, refactoring an event\ndefinition to use a type alias or a fully qualified type will change the signature topic, even\nthough the underlying type is the same. Two otherwise identical definitions of an event with the\nsame name and same field types but different field type names will have different signature\ntopics.")),(0,a.kt)("p",null,"When decoding events emitted from a contract, signature topics are now required to determine which\ntype of event to decode into. "),(0,a.kt)("h4",{id:"anonymous-events"},"Anonymous Events"),(0,a.kt)("p",null,"Annotating an event definition with ",(0,a.kt)("inlineCode",{parentName:"p"},"#[ink(anonymous)]")," (See ",(0,a.kt)("a",{parentName:"p",href:"/macros-attributes/anonymous"},"here"),"\nfor details on this attribute) prevents a signature topic from being generated and published with the\nevent."),(0,a.kt)("p",null,"It means that an indexer will not be able to index over the type of the event, which may be\ndesirable for some contracts, and would be a small gas cost optimization if necessary."),(0,a.kt)("p",null,"However, when interacting with the contract from a client, no signature topic means that another\nway is required to determine the type of the event to be decoded into (i.e. how do we know it is\na ",(0,a.kt)("inlineCode",{parentName:"p"},"Transferred")," event, not an ",(0,a.kt)("inlineCode",{parentName:"p"},"Approval")," event. One way would be to try decoding for each type\nof event defined in the metadata of the contract until one succeeds. If calling a specific\n",(0,a.kt)("inlineCode",{parentName:"p"},"message"),", it may be known up front what type of event that message will raise, so the client\ncode could just decode into that event directly."),(0,a.kt)("h2",{id:"emitting-events-in-a-constructor"},"Emitting Events in a Constructor"),(0,a.kt)("p",null,"In a constructor events are emitted via ",(0,a.kt)("inlineCode",{parentName:"p"},"Self::env().emit_event()"),".\nSee this example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(constructor)]\npub fn new(initial_value: Balance) -> Self {\n    let caller = Self::env().caller();\n    let mut balances = HashMap::new();\n    balances.insert(caller, initial_supply);\n\n    Self::env().emit_event(Transferred {\n        from: None,\n        to: Some(caller),\n        amount: initial_supply\n    });\n\n    Self { total_supply: initial_supply, balances }\n}\n")),(0,a.kt)("h2",{id:"emitting-events-from-messages"},"Emitting Events from Messages"),(0,a.kt)("p",null,"In a message events are emitted via ",(0,a.kt)("inlineCode",{parentName:"p"},"self.env().emit_event()"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(message)]\npub fn transfer(&mut self, to: AccountId, amount: Balance) -> Result {\n    let from = self.env().caller();\n    // implementation hidden\n    self.env().emit_event(Transferred {\n        from: Some(from),\n        to: Some(to),\n        amount\n    });\n    Ok(())\n}\n")),(0,a.kt)("h2",{id:"cost-of-using-events"},"Cost of using Events"),(0,a.kt)("p",null,"When using events and topics, developers should be mindful of the costs associated. Firstly: if\noptimizing for contract size, using events will increase the size of the final code size. So\nminimizing or eliminating event usage where necessary will reduce contract size. The same can be\nsaid for the execution (aka gas) costs when using events. We recommend considering the cost of\nevents when using them, and measuring the code size and gas costs with different usage patterns\nwhen optimizing."))}u.isMDXComponent=!0},31658:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/events-a50c7787c51ef0290b65675711fd9f2c.svg"}}]);
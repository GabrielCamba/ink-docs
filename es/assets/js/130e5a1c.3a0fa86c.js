"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[6915],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),g=r,m=d["".concat(s,".").concat(g)]||d[g]||u[g]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=g;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},70742:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={title:"Working with StorageVec",slug:"/datastructures/storagevec",hide_title:!0},i=void 0,l={unversionedId:"datastructures/storagevec",id:"version-5.x/datastructures/storagevec",title:"Working with StorageVec",description:"In this section we demonstrate how to work with ink! StorageVec.",source:"@site/versioned_docs/version-5.x/datastructures/storagevec.md",sourceDirName:"datastructures",slug:"/datastructures/storagevec",permalink:"/es/5.x/datastructures/storagevec",draft:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/versioned_docs/version-5.x/datastructures/storagevec.md",tags:[],version:"5.x",frontMatter:{title:"Working with StorageVec",slug:"/datastructures/storagevec",hide_title:!0},sidebar:"reference",previous:{title:"Introducci\xf3n",permalink:"/es/5.x/datastructures/overview"},next:{title:"Trabajando con Mapping",permalink:"/es/5.x/datastructures/mapping"}},s={},c=[{value:"Example: Using a <code>StorageVec</code>",id:"example-using-a-storagevec",level:2},{value:"Difference between <code>StorageVec</code> and Rusts <code>Vec</code> type",id:"difference-between-storagevec-and-rusts-vec-type",level:2},{value:"Caveats",id:"caveats",level:3},{value:"Storage Layout",id:"storage-layout",level:3},{value:"Considerations when using the <code>StorageVec</code> type",id:"considerations-when-using-the-storagevec-type",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("img",{src:"/img/title/storage.svg",className:"titlePic"}),(0,r.kt)("h1",{id:"working-with-mapping"},"Working with Mapping"),(0,r.kt)("p",null,"In this section we demonstrate how to work with ink! ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/ink_storage/5.0.0/ink_storage/struct.StorageVec.html"},(0,r.kt)("inlineCode",{parentName:"a"},"StorageVec")),"."),(0,r.kt)("h2",{id:"example-using-a-storagevec"},"Example: Using a ",(0,r.kt)("inlineCode",{parentName:"h2"},"StorageVec")),(0,r.kt)("p",null,"Here is an example of an append-only on-chain log:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\npub struct MyContract {\n    /// Assign a balance to every account.\n    on_chain_log: ink::storage::StorageVec<String>,\n}\n")),(0,r.kt)("p",null,"The following example contract utilizes a ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageVec")," to log each operation on chain (similar to emitting events but the contract can access them)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std, no_main)]\n\n#[ink::contract]\nmod mycontract {\n    use ink::prelude::{format, string::String};\n    use ink::storage::StorageVec;\n\n    #[ink(storage)]\n    pub struct MyContract {\n        /// Assign a balance to every account.\n        on_chain_log: StorageVec<String>,\n    }\n\n    impl MyContract {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self {\n                on_chain_log: Default::default(),\n            }\n        }\n\n        /// Donate money to the contract.\n        #[ink(message, payable)]\n        pub fn donate(&mut self) {\n            let caller = self.env().caller();\n            let endowment = self.env().transferred_value();\n\n            let log_message = format!("{caller:?} donated {endowment}");\n\n            self.on_chain_log.push(&log_message);\n        }\n\n        /// How many donations had the contract so far?\n        #[ink(message)]\n        pub fn log_length(&self) -> u32 {\n            self.on_chain_log.len()\n        }\n\n        /// What was the last donation to the contract?\n        #[ink(message)]\n        pub fn last_donation(&self) -> Option<String> {\n            self.on_chain_log.peek()\n        }\n    }\n}\n\n')),(0,r.kt)("h2",{id:"difference-between-storagevec-and-rusts-vec-type"},"Difference between ",(0,r.kt)("inlineCode",{parentName:"h2"},"StorageVec")," and Rusts ",(0,r.kt)("inlineCode",{parentName:"h2"},"Vec")," type"),(0,r.kt)("p",null,"Any Rust ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<T>")," will exhibit ",(0,r.kt)("inlineCode",{parentName:"p"},"Packed")," storage layout; where\n",(0,r.kt)("inlineCode",{parentName:"p"},"StorageVec")," stores each value under it's own storage key."),(0,r.kt)("p",null,"Hence, any read or write from or to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec")," on storage will load\nor store ",(0,r.kt)("em",{parentName:"p"},"all")," of its elements."),(0,r.kt)("p",null,"This can be undesirable:\nThe cost of reading or writing a ",(0,r.kt)("em",{parentName:"p"},"single")," element grows linearly\ncorresponding to the number of elements in the vector (its length).\nAdditionally, the maximum capacity of the ",(0,r.kt)("em",{parentName:"p"},"whole")," vector is limited by\nthe size of the static buffer used during ABI encoding and decoding\n(default 16 KiB)."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"StorageVec")," on the other hand allows to access each element individually.\nThus, it can theoretically grow to infinite size.\nHowever, we currently limit the length at 2 ^ 32 elements. In practice,\neven if the vector elements are single bytes, it'll allow to store\nmore than 4 GB data in blockchain storage."),(0,r.kt)("h3",{id:"caveats"},"Caveats"),(0,r.kt)("p",null,"Iterators are not provided. ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageVec")," is expected to be used to\nstore a lot elements, where iterating through the elements would be\nrather inefficient. Manually iterating over the elements using a loop\nis possible but considered an anti-pattern for most cases."),(0,r.kt)("p",null,"For the same reason, operations which would require re-ordering\nstored elements are not supported. Examples include inserting and\ndeleting elements at arbitrary positions or sorting elements."),(0,r.kt)("p",null,"The decision whether to use ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<T>")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageVec")," can be seen as an\noptimization problem with several factors:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"How large you expect the vector to grow"),(0,r.kt)("li",{parentName:"ul"},"The size of individual elements being stored"),(0,r.kt)("li",{parentName:"ul"},"How frequently reads, writes and iterations happen")),(0,r.kt)("p",null,"For example, if a vector is expected to stay small but is frequently\niterated over. Choosing a ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<T>")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageVec")," will be\npreferred as individual storage reads are much more expensive as\nopposed to retrieving and decoding the whole collection with a single\nstorage read."),(0,r.kt)("h3",{id:"storage-layout"},"Storage Layout"),(0,r.kt)("p",null,"At given ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageKey")," ",(0,r.kt)("inlineCode",{parentName:"p"},"K"),", the length of the ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageVec")," is hold.\nEach element ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," is then stored under a combination of the ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageVec"),"\nkey ",(0,r.kt)("inlineCode",{parentName:"p"},"K")," and the elements index."),(0,r.kt)("p",null,"Given ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageVec")," under key ",(0,r.kt)("inlineCode",{parentName:"p"},"K"),", the storage key ",(0,r.kt)("inlineCode",{parentName:"p"},"E")," of the ",(0,r.kt)("inlineCode",{parentName:"p"},"N"),"th\nelement is calculated as follows:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"E = scale::Encode((K, N))")),(0,r.kt)("h2",{id:"considerations-when-using-the-storagevec-type"},"Considerations when using the ",(0,r.kt)("inlineCode",{parentName:"h2"},"StorageVec")," type"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"StorageVec")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy")," type similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping"),"."),(0,r.kt)("p",null,"Hence, the same considerations apply to ",(0,r.kt)("inlineCode",{parentName:"p"},"StorageVec")," too:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://use.ink/datastructures/mapping#storage-loading-behavior"},"Storage loading behavior")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://use.ink/datastructures/mapping#use-fallible-storage-methods-for-dynamically-sized-values"},"Use fallible storage methods for dynamically sized values")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://use.ink/datastructures/mapping#updating-values"},"Updating values"))))}u.isMDXComponent=!0}}]);
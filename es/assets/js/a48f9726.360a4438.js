"use strict";(self.webpackChunkink_docs=self.webpackChunkink_docs||[]).push([[5164],{3905:(e,n,a)=>{a.d(n,{Zo:()=>u,kt:()=>f});var t=a(67294);function o(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function s(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){o(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function l(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var i=t.createContext({}),c=function(e){var n=t.useContext(i),a=n;return e&&(a="function"==typeof e?e(n):s(s({},n),e)),a},u=function(e){var n=c(e.components);return t.createElement(i.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var a=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(a),m=o,f=d["".concat(i,".").concat(m)]||d[m]||p[m]||r;return a?t.createElement(f,s(s({ref:n},u),{},{components:a})):t.createElement(f,s({ref:n},u))}));function f(e,n){var a=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=a.length,s=new Array(r);s[0]=m;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l[d]="string"==typeof e?e:o,s[1]=l;for(var c=2;c<r;c++)s[c]=a[c];return t.createElement.apply(null,s)}return t.createElement.apply(null,a)}m.displayName="MDXCreateElement"},22841:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var t=a(87462),o=(a(67294),a(3905));const r={title:"Plantilla de un Contrato",slug:"/basics/contract-template",hide_title:!0},s=void 0,l={unversionedId:"basics/contract-template",id:"basics/contract-template",title:"Plantilla de un Contrato",description:"En esta p\xe1gina cubriremos como crear un contrato b\xe1sico y explicaremos",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/basics/contract-template.md",sourceDirName:"basics",slug:"/basics/contract-template",permalink:"/es/basics/contract-template",draft:!1,editUrl:"https://github.com/paritytech/ink-docs/edit/master/docs/basics/contract-template.md",tags:[],version:"current",frontMatter:{title:"Plantilla de un Contrato",slug:"/basics/contract-template",hide_title:!0},sidebar:"reference",previous:{title:"Troubleshooting",permalink:"/es/getting-started/troubleshooting"},next:{title:"Almacenando Valores",permalink:"/es/basics/storing-values"}},i={},c=[{value:"Creando la plantilla",id:"creando-la-plantilla",level:2},{value:"Template Content",id:"template-content",level:2},{value:"Contenido de la plantilla",id:"contenido-de-la-plantilla",level:2},{value:"<code>Cargo.toml</code>",id:"cargotoml",level:3},{value:"<code>lib.rs</code>",id:"librs",level:3}],u={toc:c},d="wrapper";function p(e){let{components:n,...a}=e;return(0,o.kt)(d,(0,t.Z)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("img",{src:"/img/title/macro.svg",className:"titlePic"}),(0,o.kt)("h1",{id:"plantilla-de-un-contrato"},"Plantilla de un Contrato"),(0,o.kt)("p",null,"En esta p\xe1gina cubriremos como crear un contrato b\xe1sico y explicaremos\nsus diferentes elementos."),(0,o.kt)("h2",{id:"creando-la-plantilla"},"Creando la plantilla"),(0,o.kt)("p",null,"Cambia tu directorio de trabajo y arranca:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"cargo contract new foobar\n")),(0,o.kt)("p",null,"Esto creara una nueva carpeta para el proyecto llamada ",(0,o.kt)("inlineCode",{parentName:"p"},"foobar"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"cd foobar/\n")),(0,o.kt)("p",null,"En el fichero ",(0,o.kt)("inlineCode",{parentName:"p"},"lib.rs")," encontraras un c\xf3digo ",(0,o.kt)("inlineCode",{parentName:"p"},"scaffolded")," inicial, que podr\xe1s utilizar como punto de inicio."),(0,o.kt)("p",null,"R\xe1pidamente comprueba si compila y pasa los test triviales con:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"cargo test\n")),(0,o.kt)("p",null,"Y comprueba que puedes construir el fichero Wasm arrancando:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"cargo contract build\n")),(0,o.kt)("p",null,"Si todo esta bien, entonces estamos preparados para comenzar a programar!"),(0,o.kt)("h2",{id:"template-content"},"Template Content"),(0,o.kt)("h2",{id:"contenido-de-la-plantilla"},"Contenido de la plantilla"),(0,o.kt)("p",null,"La plantilla provee un esqueleto inicial con el que comenzar a escribir\nun contrato ink!. A continuaci\xf3n veremos el contenido del fichero.\nLos ficheros que tendr\xe1s localmente ser\xe1n similares, en estos simplemente\nhemos a\xf1adido comentarios explicativos."),(0,o.kt)("h3",{id:"cargotoml"},(0,o.kt)("inlineCode",{parentName:"h3"},"Cargo.toml")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'[package]\nname = "foobar"\nversion = "0.1.0"\nauthors = ["[your_name] <[your_email]>"]\nedition = "2021"\n\n[dependencies]\n# El crate `ink` contiene el eDSL de ink! y re-exporta\n# otros crates specificos de ink!. Por ejemplo, `ink::env`\n# es el crate `ink_env` que contiene funciones para\n# interactuar con el entorno de un contrato (pedir informaci\xf3n\n# sobre el caller, el numero de bloque actual, etc.).\nink = { version = "4.0.0-beta", default-features = false }\n\n# Las blockchains creadas con Substrate usan el codec SCALE\n# para todo lo que tenga que ver con la codificaci\xf3n y decodificaci\xf3n\n# de informaci\xf3n. Si un contrato ink! es llamado, los valores\n# que se hayan pasado tienen que ser SCALE-codificados y los\n# valores que se devuelvan han de ser SCALE-decodificados. Todos\n# los valores que son almacenados en un contrato son SCALE-codificados tambi\xe9n.\nscale = { package = "parity-scale-codec", version = "3", default-features = false, features = ["derive"] }\n\n# Este crate es usado para escribir informaci\xf3n sobre los tipos\n# de un contrato en su metadata (por ejemplo, su ABI). Esto es \n# necesario para que los clientes sepan requiere cada mensaje del contrato\n# por ejemplo, un Array y que ha de SACLE-codificar los valores\n# como un Array.\nscale-info = { version = "2.3", default-features = false, features = ["derive"], optional = true }\n\n[dev-dependencies]\n# Esta dependencia es para el framework de tests End-to-End.\nink_e2e = { path = "../../crates/e2e" }\n\n[lib]\nname = "foobar"\npath = "lib.rs"\n\n# Con la siguiente configuraci\xf3n especificamos que el compilador ha de\n# crear una librer\xeda din\xe1mica. Aunque para WebAssembly especifica\n# que el compilador debe crear un `*.wasm` sin funci\xf3n start.\ncrate-type = [\n    "cdylib",\n]\n\n[features]\ndefault = ["std"]\nstd = [\n    "ink/std",\n    "scale/std",\n    "scale-info/std",\n]\nink-as-dependency = []\n\n# Esta feature es simplemente una convenci\xf3n, para que los tests\n# end-to-end solo sean ejecutados si `cargo test` es explicitamente invocado\n# con `--features e2e-tests`.\ne2e-tests = []\n')),(0,o.kt)("h3",{id:"librs"},(0,o.kt)("inlineCode",{parentName:"h3"},"lib.rs")),(0,o.kt)("p",null,"Cada contrato ink! necesita contener:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Exactamente una estructura ",(0,o.kt)("inlineCode",{parentName:"li"},"#[ink(storage)]"),"."),(0,o.kt)("li",{parentName:"ul"},"Al menos una functi\xf3n ",(0,o.kt)("inlineCode",{parentName:"li"},"#[ink(constructor)]"),"."),(0,o.kt)("li",{parentName:"ul"},"Al menos una funci\xf3n ",(0,o.kt)("inlineCode",{parentName:"li"},"#[ink(message)]"),".")),(0,o.kt)("p",null,"El c\xf3digo ser\xe1 algo similar al siguiente, aunque hemos cambiado\nlos comentarios para explicar qu\xe9 est\xe1 pasando a alto nivel."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'// Si la feature `std` en el fichero `Cargo.toml` no est\xe1 activada\n// activamos  `no_std`, esta es la consecuencia de que la librer\xeda\n// estandard de Rust no haya sido incluida en el contrato.\n//\n// La librer\xeda estandard de Rust depende del sistema operativo\n// y Wasm es independiente de la arquitectura.\n#![cfg_attr(not(feature = "std"), no_std)]\n\n// Esta es la macro ink!, el punto inicial de tu contrato.\n// Todo lo que est\xe1 por debajo de ella parecer\xe1 c\xf3digo Rust,\n// pero en realidad ser\xe1 ejecutado a trav\xe9s de un parser en ink!.\n#[ink::contract]\npub mod flipper {\n    /// Este es el storage del contrato.\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        /// Un contructor con el que el contrato puede ser inicializado.\n        #[ink(constructor)]\n        pub fn new(init_value: bool) -> Self {\n            /* --snip-- */\n        }\n\n        /// Un contructor alternativo con el que el contrato\n        /// puede ser incializado.\n        #[ink(constructor)]\n        pub fn new_default() -> Self {\n            /* --snip-- */\n        }\n\n        /// Una funci\xf3n que puede mutar el estado del contrato y es expuesta\n        /// al mundo exterior.\n        /// \n        /// Por defecto las funciones ser\xe1 privadas, habr\xe1 que anotarlas\n        /// con `#[ink(message)]` y `pub` para que est\xe9n disponibles\n        /// desde el exterior.\n        #[ink(message)]\n        pub fn flip(&mut self) {\n            /* --snip-- */\n        }\n\n        /// Una funci\xf3n p\xfablica que no tendr\xe1 ning\xfan efecto.\n        /// \n        /// Cuando una funci\xf3n sea puramente de lectura pueden ser\n        /// invocada enviando una transacci\xf3n on-chain, normalmente\n        /// esto no se hace ya que no tienen ning\xfan efecto, y los\n        /// costes de la transacci\xf3n ser\xedan malgastados.\n        /// T\xedpicamente estas funciones ser\xe1n invocadas via RPC\n        /// para devolver el estado del contrato.\n        #[ink(message)]\n        pub fn get(&self) -> bool {\n            /* --snip-- */\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        /// Este atributo denotaque el test es ejecutado en un entorno\n        /// simulado. Hay funciones disponibles para influenciar como\n        /// el entorno de testing ser\xe1 configurado (por ejemplo, \n        /// dando un balance espec\xedfico a una cuenta).\n        #[ink::test]\n        fn default_works() {\n            /* --snip-- */\n        }\n\n        /* --snip-- */\n    }\n\n    #[cfg(all(test, feature = "e2e-tests"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::build_message;\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        /// Con este atributo el contrato ser\xe1 compilado y desplegado\n        /// en un nodo Substrate que necesariamente tendr\xe1 que estar ejecutandose.\n        ///\n        /// Ofrecemos funciones API que permiten a los desarrollardores interactuar\n        /// con el contrato. ink! se encargar\xe1 de crear transacciones con las\n        /// llamadas que ser\xe1n enviadas a la red Substrate.\n        /// \n        /// Los desarrolladores pueden declarar aserciones en el resultado\n        /// de sus transacciones, como comprobar mutaciones de estado, fallos\n        /// o costes de gas.\n        #[ink_e2e::test]\n        async fn it_works(mut client: ink_e2e::Client<C, E>) -> E2EResult<()> {\n            /* --snip-- */\n        }\n\n        /* --snip-- */\n    }\n}\n')))}p.isMDXComponent=!0}}]);